<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vue lifecycle</title>

    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>


</head>
<body>

    <div id="app">
        <span>{{ message }}</span>
    </div>

</body>

<!-- 生命周期钩子，类似于Django中间件 -->
<script type="text/javascript">
    var vm = new Vue({
        el: '#app',
        data: {
            message: 'hello',
        },

        // vm对象实例化之前：数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化
        beforeCreate:function() {
            console.log('beforeCreate');
        },

        // vm对象实例化之后：实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data 数据的初始化，el没有
        created:function() {
            console.log('created');
        },

        // vm在作用标签之前：实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。
        beforeMount() {
            console.log('beforeMount');
        },

        // vm在作用标签之后：挂在完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。
        mounted() {
            console.log('mounted');
        },

        // 数据或者属性更新之前：发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程
        beforeUpdate() {
            console.log('beforeUpdate');
        },

        // 数据或者属性更新之后：组件DOM已经更新，所以可以执行依赖于DOM的操作
        updated() {
            console.log('updated');
        },

        // 在vm实例对象销毁(destroy函数)之前调用：此时实例仍然完全可用，比如可以用this来获取实例，还可以做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件
        beforeDestroy() {
            console.log('beforeDestroy');
        },

        // 当vm实例对象销毁完成后调用：所有的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用
        destroyed() {
            console.log('destroy');
        },

    });

    

</script>

</html> 